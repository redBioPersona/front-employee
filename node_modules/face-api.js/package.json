{
  "_args": [
    [
      {
        "raw": "face-api.js@^0.16.1",
        "scope": null,
        "escapedName": "face-api.js",
        "name": "face-api.js",
        "rawSpec": "^0.16.1",
        "spec": ">=0.16.1 <0.17.0",
        "type": "range"
      },
      "D:\\webFinger\\MeteorMBES"
    ]
  ],
  "_from": "face-api.js@^0.16.1",
  "_hasShrinkwrap": false,
  "_id": "face-api.js@0.16.2",
  "_location": "/face-api.js",
  "_nodeVersion": "9.2.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/face-api.js_0.16.2_1544699526723_0.4260543871208664"
  },
  "_npmUser": {
    "name": "justadudewhohacks",
    "email": "muehler.v@gmail.com"
  },
  "_npmVersion": "6.4.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "face-api.js@^0.16.1",
    "scope": null,
    "escapedName": "face-api.js",
    "name": "face-api.js",
    "rawSpec": "^0.16.1",
    "spec": ">=0.16.1 <0.17.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/face-api.js/-/face-api.js-0.16.2.tgz",
  "_shasum": "d0f1ef98c24794e9a198049cc789d6ed27a5e202",
  "_shrinkwrap": null,
  "_spec": "face-api.js@^0.16.1",
  "_where": "D:\\webFinger\\MeteorMBES",
  "author": {
    "name": "justadudewhohacks"
  },
  "dependencies": {
    "@tensorflow/tfjs-core": "0.14.2",
    "tfjs-image-recognition-base": "^0.3.1",
    "tfjs-tiny-yolov2": "^0.4.0",
    "tslib": "^1.9.3"
  },
  "description": "JavaScript API for face detection and face recognition in the browser with tensorflow.js",
  "devDependencies": {
    "@tensorflow/tfjs-node": "^0.1.21",
    "@types/jasmine": "^2.8.8",
    "@types/node": "^10.12.12",
    "canvas": "^2.0.1",
    "jasmine": "^3.3.0",
    "jasmine-core": "^3.2.1",
    "karma": "^3.0.0",
    "karma-chrome-launcher": "^2.2.0",
    "karma-jasmine": "^1.1.2",
    "karma-typescript": "^3.0.12",
    "rollup": "^0.65.0",
    "rollup-plugin-commonjs": "^9.1.6",
    "rollup-plugin-node-resolve": "^3.3.0",
    "rollup-plugin-typescript2": "^0.16.1",
    "rollup-plugin-uglify": "^4.0.0",
    "ts-node": "^7.0.1",
    "typescript": "2.8.4"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-2iOaYTYGQC2JSspBe/mq+zTcyQgIS8rffVtXe2cePwxFLh3VbzlAbxt9d0jwbDKiOHS55LxRRB2Tb2xfIyLT1w==",
    "shasum": "d0f1ef98c24794e9a198049cc789d6ed27a5e202",
    "tarball": "https://registry.npmjs.org/face-api.js/-/face-api.js-0.16.2.tgz",
    "fileCount": 630,
    "unpackedSize": 3852865,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcEj6HCRA9TVsSAnZWagAADUYP/ifZ39+54NsDD/wYBxFj\nm3LU9rf+Vqb10NtYyrAkgBmrHLwNd/O91SltMfZsPCSqD3E4CMOJ1/Gdp+Dg\nGS3Z5GgI5LWjihFDAxIoxOUVIXEWPQdp0e/tDztTlNWYBTT/p8VRMXDpDkam\nfEXcTjVeb/hMaDJ7GkL9zhFwVIe8AuEoC2DpeFGmZhkpTrecnvTVbPdpExs2\n09qMAQga2WKxNhDeHXoP0WV4AJjVLOBg/STe94fXgB74/x7YkvHhoP48Vm/u\n1Ic89ySzvvwTcOPhRxUb70cJxEysAUQ7wBvjvbAnMdB/4VKNZ7E4F2Xlpg7I\nKpT+0zAOz1cpVEwSr4rqyrofMwkAdM/pSQMQOF+m0IT8xAcQXy9vjc51KdwJ\nBO0FelzTKKO6vUQrnLaCs5FErr9OsWtSgdpmgUX4V9TdWlwGaYHjd01O8DNz\np7XhzF6wzPWV9sG4z2SAWN3iyiGWulU77GtPxZrGUtAkMQBpoj8NfgakqhNz\n4xMe33/M0Iri9AdGy+eAe9t+cTdJy/E/9VcaIih+XhOnfUKwr+/7dkr1qetE\nTo/mv6f2O0fa1oK4qOoOsXz0P15p4/OPPLCpK1Y8Sl+IlQ5kqGHHvfBCcK/0\n9x22NVSdvntnESeRxfpPnAG9uRvvrPEfD28/v3IuZ5kaG8aQJTiMMcdttQiY\nfI2T\r\n=O1lt\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "gitHead": "6094f36ccb605e7506c3d11996d0b149a0da1fc9",
  "keywords": [
    "face",
    "detection",
    "recognition",
    "tensorflow",
    "tf"
  ],
  "license": "MIT",
  "main": "./build/commonjs/index.js",
  "maintainers": [
    {
      "name": "justadudewhohacks",
      "email": "muehler.v@gmail.com"
    }
  ],
  "module": "./build/es6/index.js",
  "name": "face-api.js",
  "optionalDependencies": {},
  "readme": "# face-api.js\r\n\r\n[![Build Status](https://travis-ci.org/justadudewhohacks/face-api.js.svg?branch=master)](https://travis-ci.org/justadudewhohacks/face-api.js)\r\n[![Slack](https://slack.bri.im/badge.svg)](https://slack.bri.im)\r\n\r\n**JavaScript API for face detection and face recognition in the browser implemented on top of the tensorflow.js core API ([tensorflow/tfjs-core](https://github.com/tensorflow/tfjs-core))**\r\n\r\nTable of Contents:\r\n\r\n* **[Resources](#resources)**\r\n  * **[Live Demos](#live-demos)**\r\n  * **[Tutorials](#tutorials)**\r\n* **[Examples](#examples)**\r\n  * **[Running the Examples](#running-the-examples)**\r\n* **[Available Models](#models)**\r\n  * **[Face Detection Models](#models-face-detection)**\r\n  * **[68 Point Face Landmark Detection Models](#models-face-landmark-detection)**\r\n  * **[Face Recognition Model](#models-face-recognition)**\r\n* **[Getting Started](#getting-started)**\r\n  * **[face-api.js for the Browser](#getting-started-browser)**\r\n  * **[face-api.js for Nodejs](#getting-started-nodejs)**\r\n* **[Usage](#usage)**\r\n  * **[Loading the Models](#usage-loading-models)**\r\n  * **[High Level API](#usage-high-level-api)**\r\n  * **[Displaying Detection Results](#usage-displaying-detection-results)**\r\n  * **[Face Detection Options](#usage-face-detection-options)**\r\n  * **[Utility Classes](#usage-utility-classes)**\r\n  * **[Other Useful Utility](#other-useful-utility)**\r\n* **[API Documentation](https://justadudewhohacks.github.io/face-api.js/docs/globals.html)**\r\n\r\n<a name=\"resources\"></a>\r\n\r\n# Resources\r\n\r\n<a name=\"live-demos\"></a>\r\n\r\n## Live Demos\r\n\r\n**[Check out the live demos!](https://justadudewhohacks.github.io/face-api.js/)**\r\n\r\n<a name=\"tutorials\"></a>\r\n\r\n## Tutorials\r\n\r\nCheck out my face-api.js tutorials:\r\n\r\n* **[face-api.js — JavaScript API for Face Recognition in the Browser with tensorflow.js](https://itnext.io/face-api-js-javascript-api-for-face-recognition-in-the-browser-with-tensorflow-js-bcc2a6c4cf07)**\r\n* **[Realtime JavaScript Face Tracking and Face Recognition using face-api.js’ MTCNN Face Detector](https://itnext.io/realtime-javascript-face-tracking-and-face-recognition-using-face-api-js-mtcnn-face-detector-d924dd8b5740)**\r\n\r\n<a name=\"examples\"></a>\r\n\r\n# Examples\r\n\r\n## Face Recognition\r\n\r\n![preview_face-detection-and-recognition](https://user-images.githubusercontent.com/31125521/41526995-1a90e4e6-72e6-11e8-96d4-8b2ccdee5f79.gif)\r\n\r\n![face-recognition-preview](https://user-images.githubusercontent.com/31125521/47384002-41e36f80-d706-11e8-8cd9-b3102c1bee67.png)\r\n\r\n## Face Similarity\r\n\r\n![preview_face-similarity](https://user-images.githubusercontent.com/31125521/40316573-0a1190c0-5d1f-11e8-8797-f6deaa344523.gif)\r\n\r\n## Face Landmark Detection\r\n\r\n![face_landmarks_boxes_2](https://user-images.githubusercontent.com/31125521/46063404-00928b00-c16d-11e8-8f29-e9c50afd2bc8.jpg)\r\n\r\n![preview_face_landmarks](https://user-images.githubusercontent.com/31125521/41507950-e121b05e-723c-11e8-89f2-d8f9348a8e86.png)\r\n\r\n## Realtime Face Tracking\r\n\r\n![output](https://user-images.githubusercontent.com/31125521/47383860-ea450400-d705-11e8-9880-d5d15d952661.gif)\r\n\r\n## MTCNN\r\n\r\n![mtcnn-preview](https://user-images.githubusercontent.com/31125521/42756818-0a41edaa-88fe-11e8-9033-8cd141b0fa09.gif)\r\n\r\n<a name=\"running-the-examples\"></a>\r\n\r\n## Running the Examples\r\n\r\nClone the repository:\r\n\r\n``` bash\r\ngit clone https://github.com/justadudewhohacks/face-api.js.git\r\n```\r\n\r\n### Running the Browser Examples\r\n\r\n``` bash\r\ncd face-api.js/examples/examples-browser\r\nnpm i\r\nnpm start\r\n```\r\n\r\nBrowse to http://localhost:3000/.\r\n\r\n### Running the Nodejs Examples\r\n\r\n``` bash\r\ncd face-api.js/examples/examples-nodejs\r\nnpm i\r\n```\r\n\r\nNow run one of the examples using ts-node:\r\n\r\n``` bash\r\nts-node faceDetection.ts\r\n```\r\n\r\nOr simply compile and run them with node:\r\n\r\n``` bash\r\ntsc faceDetection.ts\r\nnode faceDetection.js\r\n```\r\n\r\n<a name=\"models\"></a>\r\n\r\n# Available Models\r\n\r\n<a name=\"models-face-detection\"></a>\r\n\r\n## Face Detection Models\r\n\r\n### SSD Mobilenet V1\r\n\r\nFor face detection, this project implements a SSD (Single Shot Multibox Detector) based on MobileNetV1. The neural net will compute the locations of each face in an image and will return the bounding boxes together with it's probability for each face. This face detector is aiming towards obtaining high accuracy in detecting face bounding boxes instead of low inference time. The size of the quantized model is about 5.4 MB (**ssd_mobilenetv1_model**).\r\n\r\nThe face detection model has been trained on the [WIDERFACE dataset](http://mmlab.ie.cuhk.edu.hk/projects/WIDERFace/) and the weights are provided by [yeephycho](https://github.com/yeephycho) in [this](https://github.com/yeephycho/tensorflow-face-detection) repo.\r\n\r\n### Tiny Face Detector\r\n\r\nThe Tiny Face Detector is a very performant, realtime face detector, which is much faster, smaller and less resource consuming compared to the SSD Mobilenet V1 face detector, in return it performs slightly less well on detecting small faces. This model is extremely mobile and web friendly, thus it should be your GO-TO face detector on mobile devices and resource limited clients. The size of the quantized model is only 190 KB (**tiny_face_detector_model**).\r\n\r\nThe face detector has been trained on a custom dataset of ~14K images labeled with bounding boxes. Furthermore the model has been trained to predict bounding boxes, which entirely cover facial feature points, thus it in general produces better results in combination with subsequent face landmark detection than SSD Mobilenet V1.\r\n\r\nThis model is basically an even tinier version of Tiny Yolo V2, replacing the regular convolutions of Yolo with depthwise separable convolutions. Yolo is fully convolutional, thus can easily adapt to different input image sizes to trade off accuracy for performance (inference time).\r\n\r\n### MTCNN\r\n\r\n**Note, this model is mostly kept in this repo for experimental reasons. In general the other face detectors should perform better, but of course you are free to play around with MTCNN.**\r\n\r\nMTCNN (Multi-task Cascaded Convolutional Neural Networks) represents an alternative face detector to SSD Mobilenet v1 and Tiny Yolo v2, which offers much more room for configuration. By tuning the input parameters, MTCNN should be able to detect a wide range of face bounding box sizes. MTCNN is a 3 stage cascaded CNN, which simultaneously returns 5 face landmark points along with the bounding boxes and scores for each face. Additionally the model size is only 2MB.\r\n\r\nMTCNN has been presented in the paper [Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks](https://kpzhang93.github.io/MTCNN_face_detection_alignment/paper/spl.pdf) by Zhang et al. and the model weights are provided in the official [repo](https://github.com/kpzhang93/MTCNN_face_detection_alignment) of the MTCNN implementation.\r\n\r\n<a name=\"models-face-landmark-detection\"></a>\r\n\r\n## 68 Point Face Landmark Detection Models\r\n\r\nThis package implements a very lightweight and fast, yet accurate 68 point face landmark detector. The default model has a size of only 350kb (**face_landmark_68_model**) and the tiny model is only 80kb (**face_landmark_68_tiny_model**). Both models employ the ideas of depthwise separable convolutions as well as densely connected blocks. The models have been trained on a dataset of ~35k face images labeled with 68 face landmark points.\r\n\r\n<a name=\"models-face-recognition\"></a>\r\n\r\n## Face Recognition Model\r\n\r\nFor face recognition, a ResNet-34 like architecture is implemented to compute a face descriptor (a feature vector with 128 values) from any given face image, which is used to describe the characteristics of a persons face. The model is **not** limited to the set of faces used for training, meaning you can use it for face recognition of any person, for example yourself. You can determine the similarity of two arbitrary faces by comparing their face descriptors, for example by computing the euclidean distance or using any other classifier of your choice.\r\n\r\nThe neural net is equivalent to the **FaceRecognizerNet** used in [face-recognition.js](https://github.com/justadudewhohacks/face-recognition.js) and the net used in the [dlib](https://github.com/davisking/dlib/blob/master/examples/dnn_face_recognition_ex.cpp) face recognition example. The weights have been trained by [davisking](https://github.com/davisking) and the model achieves a prediction accuracy of 99.38% on the LFW (Labeled Faces in the Wild) benchmark for face recognition.\r\n\r\nThe size of the quantized model is roughly 6.2 MB (**face_recognition_model**).\r\n\r\n<a name=\"getting-started\"></a>\r\n\r\n# Getting Started\r\n\r\n<a name=\"getting-started-browser\"></a>\r\n\r\n## face-api.js for the Browser\r\n\r\nSimply include the latest script from [dist/face-api.js](https://github.com/justadudewhohacks/face-api.js/tree/master/dist).\r\n\r\nOr install it via npm:\r\n\r\n``` bash\r\nnpm i face-api.js\r\n```\r\n\r\n<a name=\"getting-started-nodejs\"></a>\r\n\r\n## face-api.js for Nodejs\r\n\r\nWe can use the equivalent API in a nodejs environment by polyfilling some browser specifics, such as HTMLImageElement, HTMLCanvasElement and ImageData. The easiest way to do so is by installing the node-canvas package.\r\n\r\nAlternatively you can simply construct your own tensors from image data and pass tensors as inputs to the API.\r\n\r\nFurthermore you want to install @tensorflow/tfjs-node (not required, but highly recommended), which speeds things up drastically by compiling and binding to the native Tensorflow C++ library:\r\n\r\n``` bash\r\nnpm i face-api.js canvas @tensorflow/tfjs-node\r\n```\r\n\r\nNow we simply monkey patch the environment to use the polyfills:\r\n\r\n``` javascript\r\n// import nodejs bindings to native tensorflow,\r\n// not required, but will speed up things drastically (python required)\r\nimport '@tensorflow/tfjs-node';\r\n\r\n// implements nodejs wrappers for HTMLCanvasElement, HTMLImageElement, ImageData\r\nimport * as canvas from 'canvas';\r\n\r\nimport * as faceapi from 'face-api.js';\r\n\r\n// patch nodejs environment, we need to provide an implementation of\r\n// HTMLCanvasElement and HTMLImageElement, additionally an implementation\r\n// of ImageData is required, in case you want to use the MTCNN\r\nconst { Canvas, Image, ImageData } = canvas\r\nfaceapi.env.monkeyPatch({ Canvas, Image, ImageData })\r\n```\r\n\r\n# Usage\r\n\r\n<a name=\"usage-loading-models\"></a>\r\n\r\n## Loading the Models\r\n\r\nTo load a model, you have provide the corresponding manifest.json file as well as the model weight files (shards) as assets. Simply copy them to your public or assets folder. The manifest.json and shard files of a model have to be located in the same directory / accessible under the same route.\r\n\r\nAssuming the models reside in **public/models**:\r\n\r\n``` javascript\r\nawait faceapi.loadSsdMobilenetv1Model('/models')\r\n// accordingly for the other models:\r\n// await faceapi.loadTinyFaceDetectorModel('/models')\r\n// await faceapi.loadMtcnnModel('/models')\r\n// await faceapi.loadFaceLandmarkModel('/models')\r\n// await faceapi.loadFaceLandmarkTinyModel('/models')\r\n// await faceapi.loadFaceRecognitionModel('/models')\r\n```\r\n\r\nAll global neural network instances are exported via faceapi.nets:\r\n\r\n``` javascript\r\nconsole.log(faceapi.nets)\r\n```\r\n\r\nThe following is equivalent to `await faceapi.loadSsdMobilenetv1Model('/models')`:\r\n\r\n``` javascript\r\nawait faceapi.nets.ssdMobilenetv1.loadFromUri('/models')\r\n```\r\n\r\nIn a nodejs environment you can furthermore load the models directly from disk:\r\n\r\n``` javascript\r\nawait faceapi.nets.ssdMobilenetv1.loadFromDisk('./models')\r\n```\r\n\r\nYou can also load the model from a tf.NamedTensorMap:\r\n\r\n``` javascript\r\nawait faceapi.nets.ssdMobilenetv1.loadFromWeightMap(weightMap)\r\n```\r\n\r\nAlternatively, you can also create own instances of the neural nets:\r\n\r\n``` javascript\r\nconst net = new faceapi.SsdMobilenetv1()\r\nawait net.load('/models')\r\n```\r\n\r\nYou can also load the weights as a Float32Array (in case you want to use the uncompressed models):\r\n\r\n``` javascript\r\n// using fetch\r\nnet.load(await faceapi.fetchNetWeights('/models/face_detection_model.weights'))\r\n\r\n// using axios\r\nconst res = await axios.get('/models/face_detection_model.weights', { responseType: 'arraybuffer' })\r\nconst weights = new Float32Array(res.data)\r\nnet.load(weights)\r\n```\r\n\r\n## High Level API\r\n\r\nIn the following **input** can be an HTML img, video or canvas element or the id of that element.\r\n\r\n``` html\r\n<img id=\"myImg\" src=\"images/example.png\" />\r\n<video id=\"myVideo\" src=\"media/example.mp4\" />\r\n<canvas id=\"myCanvas\" />\r\n```\r\n\r\n``` javascript\r\nconst input = document.getElementById('myImg')\r\n// const input = document.getElementById('myVideo')\r\n// const input = document.getElementById('myCanvas')\r\n// or simply:\r\n// const input = 'myImg'\r\n```\r\n\r\n### Detecting Faces\r\n\r\nDetect all faces in an image. Returns **Array<[FaceDetection](#interface-face-detection)>**:\r\n\r\n``` javascript\r\nconst detections = await faceapi.detectAllFaces(input)\r\n```\r\n\r\nDetect the face with the highest confidence score in an image. Returns **[FaceDetection](#interface-face-detection) | undefined**:\r\n\r\n``` javascript\r\nconst detection = await faceapi.detectSingleFace(input)\r\n```\r\n\r\nBy default **detectAllFaces** and **detectSingleFace** utilize the SSD Mobilenet V1 Face Detector. You can specify the face detector by passing the corresponding options object:\r\n\r\n``` javascript\r\nconst detections1 = await faceapi.detectAllFaces(input, new faceapi.SsdMobilenetv1Options())\r\nconst detections2 = await faceapi.detectAllFaces(input, new faceapi.TinyFaceDetectorOptions())\r\nconst detections3 = await faceapi.detectAllFaces(input, new faceapi.MtcnnOptions())\r\n```\r\n\r\nYou can tune the options of each face detector as shown [here](#usage-face-detection-options).\r\n\r\n### Detecting 68 Face Landmark Points\r\n\r\n**After face detection, we can furthermore predict the facial landmarks for each detected face as follows:**\r\n\r\nDetect all faces in an image + computes 68 Point Face Landmarks for each detected face. Returns **Array<[FaceDetectionWithLandmarks](#interface-face-detection-with-landmarks)>**:\r\n\r\n``` javascript\r\nconst detectionsWithLandmarks = await faceapi.detectAllFaces(input).withFaceLandmarks()\r\n```\r\n\r\nDetect the face with the highest confidence score in an image + computes 68 Point Face Landmarks for that face. Returns **[FaceDetectionWithLandmarks](#interface-face-detection-with-landmarks) | undefined**:\r\n\r\n``` javascript\r\nconst detectionWithLandmarks = await faceapi.detectSingleFace(input).withFaceLandmarks()\r\n```\r\n\r\nYou can also specify to use the tiny model instead of the default model:\r\n\r\n``` javascript\r\nconst useTinyModel = true\r\nconst detectionsWithLandmarks = await faceapi.detectAllFaces(input).withFaceLandmarks(useTinyModel)\r\n```\r\n\r\n### Computing Face Descriptors\r\n\r\n**After face detection and facial landmark prediction the face descriptors for each face can be computed as follows:**\r\n\r\nDetect all faces in an image + computes 68 Point Face Landmarks for each detected face. Returns **Array<[FullFaceDescription](#interface-full-face-description)>**:\r\n\r\n``` javascript\r\nconst fullFaceDescriptions = await faceapi.detectAllFaces(input).withFaceLandmarks().withFaceDescriptors()\r\n```\r\n\r\nDetect the face with the highest confidence score in an image + computes 68 Point Face Landmarks and face descriptor for that face. Returns **[FullFaceDescription](#interface-full-face-description) | undefined**:\r\n\r\n``` javascript\r\nconst fullFaceDescription = await faceapi.detectSingleFace(input).withFaceLandmarks().withFaceDescriptor()\r\n```\r\n\r\n### Face Recognition by Matching Descriptors\r\n\r\nTo perform face recognition, one can use faceapi.FaceMatcher to compare reference face descriptors to query face descriptors.\r\n\r\nFirst, we initialize the FaceMatcher with the reference data, for example we can simply detect faces in a **referenceImage** and match the descriptors of the detected faces to faces of subsquent images:\r\n\r\n``` javascript\r\nconst fullFaceDescriptions = await faceapi\r\n  .detectAllFaces(referenceImage)\r\n  .withFaceLandmarks()\r\n  .withFaceDescriptors()\r\n\r\nif (!fullFaceDescriptions.length) {\r\n  return\r\n}\r\n\r\n// create FaceMatcher with automatically assigned labels\r\n// from the detection results for the reference image\r\nconst faceMatcher = new faceapi.FaceMatcher(fullFaceDescriptions)\r\n```\r\n\r\nNow we can recognize a persons face shown in **queryImage1**:\r\n\r\n``` javascript\r\nconst singleFullFaceDescription = await faceapi\r\n  .detectSingleFace(queryImage1)\r\n  .withFaceLandmarks()\r\n  .withFaceDescriptor()\r\n\r\nif (singleFullFaceDescription) {\r\n  const bestMatch = faceMatcher.findBestMatch(singleFullFaceDescription.descriptor)\r\n  console.log(bestMatch.toString())\r\n}\r\n```\r\n\r\nOr we can recognize all faces shown in **queryImage2**:\r\n\r\n``` javascript\r\nconst fullFaceDescriptions = await faceapi\r\n  .detectAllFaces(queryImage2)\r\n  .withFaceLandmarks()\r\n  .withFaceDescriptors()\r\n\r\nfullFaceDescriptions.forEach(fd => {\r\n  const bestMatch = faceMatcher.findBestMatch(fd.descriptor)\r\n  console.log(bestMatch.toString())\r\n})\r\n```\r\n\r\nYou can also create labeled reference descriptors as follows:\r\n\r\n``` javascript\r\nconst labeledDescriptors = [\r\n  new faceapi.LabeledFaceDescriptors(\r\n    'obama',\r\n    [descriptorObama1, descriptorObama2]\r\n  ),\r\n  new faceapi.LabeledFaceDescriptors(\r\n    'trump',\r\n    [descriptorTrump]\r\n  )\r\n]\r\n\r\nconst faceMatcher = new faceapi.FaceMatcher(labeledDescriptors)\r\n```\r\n\r\n<a name=\"usage-displaying-detection-results\"></a>\r\n\r\n## Displaying Detection Results\r\n\r\nDrawing the detected faces into a canvas:\r\n\r\n``` javascript\r\nconst detections = await faceapi.detectAllFaces(input)\r\n\r\n// resize the detected boxes in case your displayed image has a different size then the original\r\nconst detectionsForSize = detections.map(det => det.forSize(input.width, input.height))\r\n// draw them into a canvas\r\nconst canvas = document.getElementById('overlay')\r\ncanvas.width = input.width\r\ncanvas.height = input.height\r\nfaceapi.drawDetection(canvas, detectionsForSize, { withScore: true })\r\n```\r\n\r\nDrawing face landmarks into a canvas:\r\n\r\n``` javascript\r\nconst detectionsWithLandmarks = await faceapi\r\n  .detectAllFaces(input)\r\n  .withFaceLandmarks()\r\n\r\n// resize the detected boxes and landmarks in case your displayed image has a different size then the original\r\nconst detectionsWithLandmarksForSize = detectionsWithLandmarks.map(det => det.forSize(input.width, input.height))\r\n// draw them into a canvas\r\nconst canvas = document.getElementById('overlay')\r\ncanvas.width = input.width\r\ncanvas.height = input.height\r\nfaceapi.drawLandmarks(canvas, detectionsWithLandmarks, { drawLines: true })\r\n```\r\n\r\nFinally you can also draw boxes with custom text:\r\n\r\n``` javascript\r\nconst boxesWithText = [\r\n  new faceapi.BoxWithText(new faceapi.Rect(x, y, width, height), text))\r\n  new faceapi.BoxWithText(new faceapi.Rect(0, 0, 50, 50), 'some text'))\r\n]\r\n\r\nconst canvas = document.getElementById('overlay')\r\nfaceapi.drawDetection(canvas, boxesWithText)\r\n```\r\n\r\n<a name=\"usage-face-detection-options\"></a>\r\n\r\n## Face Detection Options\r\n\r\n### SsdMobilenetv1Options\r\n\r\n``` javascript\r\nexport interface ISsdMobilenetv1Options {\r\n  // minimum confidence threshold\r\n  // default: 0.5\r\n  minConfidence?: number\r\n\r\n  // maximum number of faces to return\r\n  // default: 100\r\n  maxResults?: number\r\n}\r\n\r\n// example\r\nconst options = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.8 })\r\n```\r\n\r\n### TinyFaceDetectorOptions\r\n\r\n``` javascript\r\nexport interface ITinyFaceDetectorOptions {\r\n  // size at which image is processed, the smaller the faster,\r\n  // but less precise in detecting smaller faces, must be divisible\r\n  // by 32, common sizes are 128, 160, 224, 320, 416, 512, 608,\r\n  // for face tracking via webcam I would recommend using smaller sizes,\r\n  // e.g. 128, 160, for detecting smaller faces use larger sizes, e.g. 512, 608\r\n  // default: 416\r\n  inputSize?: number\r\n\r\n  // minimum confidence threshold\r\n  // default: 0.5\r\n  scoreThreshold?: number\r\n}\r\n\r\n// example\r\nconst options = new faceapi.TinyFaceDetectorOptions({ inputSize: 320 })\r\n```\r\n\r\n### MtcnnOptions\r\n\r\n``` javascript\r\nexport interface IMtcnnOptions {\r\n  // minimum face size to expect, the higher the faster processing will be,\r\n  // but smaller faces won't be detected\r\n  // default: 20\r\n  minFaceSize?: number\r\n\r\n  // the score threshold values used to filter the bounding\r\n  // boxes of stage 1, 2 and 3\r\n  // default: [0.6, 0.7, 0.7]\r\n  scoreThresholds?: number[]\r\n\r\n  // scale factor used to calculate the scale steps of the image\r\n  // pyramid used in stage 1\r\n  // default: 0.709\r\n  scaleFactor?: number\r\n\r\n  // number of scaled versions of the input image passed through the CNN\r\n  // of the first stage, lower numbers will result in lower inference time,\r\n  // but will also be less accurate\r\n  // default: 10\r\n  maxNumScales?: number\r\n\r\n  // instead of specifying scaleFactor and maxNumScales you can also\r\n  // set the scaleSteps manually\r\n  scaleSteps?: number[]\r\n}\r\n\r\n// example\r\nconst options = new faceapi.MtcnnOptions({ minFaceSize: 100, scaleFactor: 0.8 })\r\n```\r\n\r\n<a name=\"usage-utility-classes\"></a>\r\n\r\n## Utility Classes\r\n\r\n### IBox\r\n\r\n``` javascript\r\nexport interface IBox {\r\n  x: number\r\n  y: number\r\n  width: number\r\n  height: number\r\n}\r\n```\r\n\r\n<a name=\"interface-face-detection\"></a>\r\n\r\n### IFaceDetection\r\n\r\n``` javascript\r\nexport interface IFaceDetection {\r\n  score: number\r\n  box: Box\r\n}\r\n```\r\n\r\n<a name=\"interface-face-landmarks\"></a>\r\n\r\n### IFaceLandmarks\r\n\r\n``` javascript\r\nexport interface IFaceLandmarks {\r\n  positions: Point[]\r\n  shift: Point\r\n}\r\n```\r\n\r\n<a name=\"interface-face-detection-with-landmarks\"></a>\r\n\r\n### IFaceDetectionWithLandmarks\r\n\r\n``` javascript\r\nexport interface IFaceDetectionWithLandmarks {\r\n  detection: FaceDetection\r\n  landmarks: FaceLandmarks\r\n}\r\n```\r\n\r\n<a name=\"interface-full-face-description\"></a>\r\n\r\n### IFullFaceDescription\r\n\r\n``` javascript\r\nexport interface IFullFaceDescription extends IFaceDetectionWithLandmarks {\r\n  descriptor: Float32Array\r\n}\r\n```\r\n\r\n<a name=\"other-useful-utility\"></a>\r\n\r\n## Other Useful Utility\r\n\r\n### Using the Low Level API\r\n\r\nInstead of using the high level API, you can directly use the forward methods of each neural network:\r\n\r\n``` javascript\r\nconst detections1 = await faceapi.ssdMobilenetv1(input, options)\r\nconst detections2 = await faceapi.tinyFaceDetector(input, options)\r\nconst detections3 = await faceapi.mtcnn(input, options)\r\nconst landmarks1 = await faceapi.detectFaceLandmarks(faceImage)\r\nconst landmarks2 = await faceapi.detectFaceLandmarksTiny(faceImage)\r\nconst descriptor = await faceapi.computeFaceDescriptor(alignedFaceImage)\r\n```\r\n\r\n### Extracting a Canvas for an Image Region\r\n\r\n``` javascript\r\nconst regionsToExtract = [\r\n  new faceapi.Rect(0, 0, 100, 100)\r\n]\r\n// actually extractFaces is meant to extract face regions from bounding boxes\r\n// but you can also use it to extract any other region\r\nconst canvases = await faceapi.extractFaces(input, regionsToExtract)\r\n```\r\n\r\n### Euclidean Distance\r\n\r\n``` javascript\r\n// ment to be used for computing the euclidean distance between two face descriptors\r\nconst dist = faceapi.euclideanDistance([0, 0], [0, 10])\r\nconsole.log(dist) // 10\r\n```\r\n\r\n### Retrieve the Face Landmark Points and Contours\r\n\r\n``` javascript\r\nconst landmarkPositions = landmarks.positions\r\n\r\n// or get the positions of individual contours,\r\n// only available for 68 point face ladnamrks (FaceLandmarks68)\r\nconst jawOutline = landmarks.getJawOutline()\r\nconst nose = landmarks.getNose()\r\nconst mouth = landmarks.getMouth()\r\nconst leftEye = landmarks.getLeftEye()\r\nconst rightEye = landmarks.getRightEye()\r\nconst leftEyeBbrow = landmarks.getLeftEyeBrow()\r\nconst rightEyeBrow = landmarks.getRightEyeBrow()\r\n```\r\n\r\n### Fetch and Display Images from an URL\r\n\r\n``` html\r\n<img id=\"myImg\" src=\"\">\r\n```\r\n\r\n``` javascript\r\nconst image = await faceapi.fetchImage('/images/example.png')\r\n\r\nconsole.log(image instanceof HTMLImageElement) // true\r\n\r\n// displaying the fetched image content\r\nconst myImg = document.getElementById('myImg')\r\nmyImg.src = image.src\r\n```\r\n\r\n### Fetching JSON\r\n\r\n``` javascript\r\nconst json = await faceapi.fetchJson('/files/example.json')\r\n```\r\n\r\n### Creating an Image Picker\r\n\r\n``` html\r\n<img id=\"myImg\" src=\"\">\r\n<input id=\"myFileUpload\" type=\"file\" onchange=\"uploadImage()\" accept=\".jpg, .jpeg, .png\">\r\n```\r\n\r\n``` javascript\r\nasync function uploadImage() {\r\n  const imgFile = document.getElementById('myFileUpload').files[0]\r\n  // create an HTMLImageElement from a Blob\r\n  const img = await faceapi.bufferToImage(imgFile)\r\n  document.getElementById('myImg').src = img.src\r\n}\r\n```\r\n\r\n### Creating a Canvas Element from an Image or Video Element\r\n\r\n``` html\r\n<img id=\"myImg\" src=\"images/example.png\" />\r\n<video id=\"myVideo\" src=\"media/example.mp4\" />\r\n```\r\n\r\n``` javascript\r\nconst canvas1 = faceapi.createCanvasFromMedia(document.getElementById('myImg'))\r\nconst canvas2 = faceapi.createCanvasFromMedia(document.getElementById('myVideo'))\r\n```\r\n",
  "readmeFilename": "README.md",
  "scripts": {
    "build": "rm -rf ./build && rm -rf ./dist && npm run rollup && npm run rollup-min && npm run tsc && npm run tsc-es6",
    "docs": "typedoc --options ./typedoc.config.js ./src",
    "rollup": "rollup -c rollup.config.js",
    "rollup-min": "rollup -c rollup.config.js --environment minify:true",
    "test": "karma start",
    "test-all": "npm run test-browser && npm run test-node",
    "test-browser": "karma start --single-run",
    "test-cpu": "set BACKEND_CPU=true&& karma start",
    "test-exclude-uncompressed": "set EXCLUDE_UNCOMPRESSED=true&& karma start",
    "test-facelandmarknets": "set UUT=faceLandmarkNet&& karma start",
    "test-facerecognitionnet": "set UUT=faceRecognitionNet&& karma start",
    "test-mtcnn": "set UUT=mtcnn&& karma start",
    "test-node": "ts-node node_modules/jasmine/bin/jasmine --config=jasmine-node.js",
    "test-node-exclude-uncompressed": "set EXCLUDE_UNCOMPRESSED=true&& ts-node node_modules/jasmine/bin/jasmine --config=jasmine-node.js",
    "test-ssdmobilenetv1": "set UUT=ssdMobilenetv1&& karma start",
    "test-tinyfacedetector": "set UUT=tinyFaceDetector&& karma start",
    "tsc": "tsc",
    "tsc-es6": "tsc --p tsconfig.es6.json"
  },
  "typings": "./build/commonjs/index.d.ts",
  "version": "0.16.2"
}
